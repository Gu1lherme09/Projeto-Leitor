{% extends "base.html" %}
{% load static %}
{% block title %}Leitor de Disco - Arquivos Duplicados{% endblock %}
{% block content %}

        <header class="main-header">
            <div>
                <h1>Arquivos Duplicados</h1>
                <p class="subtitle">Visualize grupos de arquivos com mesmo tamanho e hash para limpeza segura.</p>
            </div>
            <div class="header-actions">
                <form method="post"
                    action="{% url 'duplicados' %}"
                    id="form-recalcular-duplicados">
                    {% csrf_token %}
                    <button class="btn primary" type="submit" id="btn-recalcular-duplicados">
                        Recalcular duplicados
                    </button>
                </form>
            </div>
        </header>
                <section class="grid-2">
            <article class="card">
                <header class="card-header">
                    <h2>Resumo dos duplicados</h2>
                    <span class="card-subtitle">Estat√≠sticas gerais da √∫ltima varredura.</span>
                </header>
                <div class="summary-grid">
                    <div class="summary-item">
                        <span class="summary-label">Arquivos duplicados</span>
                        <span class="summary-value">
                            {{ total_duplicados|default:"0" }}
                        </span>
                        <span class="summary-sub">arquivos que t√™m pelo menos um clone</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Grupos de duplicados</span>
                        <span class="summary-value">
                            {{ total_grupos|default:"0" }}
                        </span>
                        <span class="summary-sub">conjuntos com 2+ arquivos id√™nticos</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Espa√ßo desperdi√ßado</span>
                        <span class="summary-value">
                            {{ espaco_duplicado_gb|floatformat:1 }} GB
                        </span>
                        <span class="summary-sub">poderia ser liberado com limpeza</span>
                    </div>
                </div>
            </article>

            <article class="card center" id="integridade-card">
                <header class="card-header">
                    <h2>Recalcular duplicados</h2>
                    <span class="card-subtitle">
                        Acompanhe o progresso enquanto o hash √© calculado.
                    </span>
                </header>

                <div class="integridade-circle-wrapper">
                    <svg class="integridade-circle" viewBox="0 0 120 120">
                        <circle class="integridade-circle-bg" cx="60" cy="60" r="52"></circle>
                        <circle class="integridade-circle-fg" id="integridade-circle-fg" cx="60" cy="60" r="52"></circle>
                    </svg>

                    <div class="integridade-circle-inner">
                        <span id="integridade-percent">100%</span>
                        <small id="integridade-status">aguardando</small>
                    </div>
                </div>

                <p id="integridade-text">
                    Clique em <strong>Recalcular duplicados</strong> para iniciar o c√°lculo de hash.
                </p>
            </article>
        </section>
        {% if grupos %}
<section class="grid-3" style="margin-top: 18px;">
    <article class="card center">
        <header class="card-header">
            <div>
                <h2>√önicos vs repetidos</h2>
                <span class="card-subtitle" id="dup-counter">
                    Calculando estat√≠sticas...
                </span>
            </div>
        </header>
        <div class="donut-container">
            <div class="donut" style="border:none; width:220px; height:220px;">
                <canvas id="dupExtChart"></canvas>
            </div>
        </div>
    </article>

    <article class="card center">
        <header class="card-header">
            <h2>Pastas principais</h2>
            <span class="card-subtitle">
                Top pastas dos grupos vis√≠veis
            </span>
        </header>
        <div class="donut-container">
            <div class="donut" style="border:none; width:220px; height:220px;">
                <canvas id="dupFolderChart"></canvas>
            </div>
        </div>
    </article>

    <article class="card center">
        <header class="card-header">
            <h2>Impacto dos duplicados</h2>
            <span class="card-subtitle">
                Arquivos base vs duplicados extras (grupos vis√≠veis)
            </span>
        </header>
        <div class="donut-container">
            <div class="donut" style="border:none; width:220px; height:220px;">
                <canvas id="dupWasteChart"></canvas>
            </div>
        </div>
    </article>
</section>
{% endif %}

       <section class="card">
    <header class="card-header">
        <h2>Grupos de arquivos duplicados</h2>
        <span class="card-subtitle">
            Arquivos com mesmo tamanho e hash MD5.
        </span>
    </header>

    <div class="duplicates-filters">
        <div class="search-field">
            <label for="filtro_ext">Filtrar por extens√£o</label>
            <input class="input" id="filtro_ext" type="text" placeholder="Ex: .mp4, .zip, .pdf">
        </div>
        <div class="search-field">
            <label for="filtro_pasta">Filtrar por pasta</label>
            <input class="input" id="filtro_pasta" type="text" placeholder="pesquise pelo nome da pasta ou caminho completo">
        </div>
    </div>

    {% if not hash_disponivel %}
        <p style="margin-top: 10px; font-size: 13px; color: var(--text-muted);">
            Nenhum hash MD5 encontrado no cache. Clique em <strong>Recalcular duplicados</strong>
            para gerar os hashes a partir do cache.
        </p>
    {% endif %}

    {% if grupos %}
        <div id="dup-groups">
            {% for grupo in grupos %}
                <div class="duplicate-group">
                    <div class="duplicate-group-header">
                        <div>
                            <span class="badge badge-ext">.{{ grupo.ext }}</span>
                            <span class="group-title">Grupo #{{ grupo.id }}</span>
                        </div>
                        <div class="group-meta">
                            <span class="mono">Hash: {{ grupo.hash }}</span>
                            <span class="badge badge-dup-count">
                                {{ grupo.qtd_arquivos }} arquivos
                            </span>
                        </div>
                    </div>

                    <div class="table-wrapper">
                        <table class="table table-compact">
                            <thead>
                                <tr>
                                    <th>Nome</th>
                                    <th>Caminho completo</th>
                                    <th>Data modifica√ß√£o</th>
                                    <th>Origem</th>
                                </tr>
                            </thead>
                            <tbody>
                                {% for arq in grupo.arquivos %}
                                    <tr data-size-bytes="{{ arq.tamanho_bytes|default:'0' }}"> 
                                        <td>{{ arq.nome }}</td>
                                        <td class="col-path">{{ arq.caminho }}</td>
                                        <td>{{ arq.data_mod }}</td>
                                        <td>
                                            <span class="badge badge-cache">Cache</span>
                                        </td>
                                    </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                    </div>
                </div>
            {% endfor %}
        </div>

        <div class="table-footer table-footer--dup">
            <span id="dup-info">
                Mostrando {{ grupos|length }} de {{ total_grupos }} grupos de duplicados.
            </span>

            <div id="dup-pagination"></div>
        </div>
    {% else %}
        {% if hash_disponivel %}
            <p style="margin-top: 10px; font-size: 13px; color: var(--text-muted);">
                Nenhum grupo de arquivos duplicados encontrado na √∫ltima varredura.
            </p>
        {% endif %}
    {% endif %}
</section>

<script>
document.addEventListener("DOMContentLoaded", function () {
    const filtroExt   = document.getElementById("filtro_ext");
    const filtroPasta = document.getElementById("filtro_pasta");
    const infoEl      = document.getElementById("dup-info");
    const formRecalc  = document.getElementById("form-recalcular-duplicados");

    function compactFolderLabel(label, maxLen = 18) {
        if (!label) return "(raiz)";
        label = label.trim();

        if (label.length <= maxLen) {
            return label;
        }

        const half = Math.floor((maxLen - 1) / 2);
        const start = label.slice(0, half);
        const end   = label.slice(-half);

        return start + "‚Ä¶" + end;   // exemplo: "Microsoft3D‚Ä¶2544.0_x64_"
    }


    // =========================
    // CRON√îMETRO / LOADER DE INTEGRIDADE (OPCIONAL)
    // =========================
    const integridadeCircle = document.getElementById("integridade-circle-fg");
    const integridadePercent = document.getElementById("integridade-percent");
    const integridadeStatus  = document.getElementById("integridade-status");
    const integridadeText    = document.getElementById("integridade-text");

    let integridadeInterval = null;
    let integridadeProg = 100;
    const CIRCLE_RADIUS = 52;
    const CIRCLE_CIRC   = 2 * Math.PI * CIRCLE_RADIUS;

    if (integridadeCircle) {
        integridadeCircle.style.strokeDasharray = CIRCLE_CIRC;
    }

    function setIntegridadeProgress(p) {
        if (!integridadeCircle || !integridadePercent) return;
        const val = Math.max(0, Math.min(100, p));
        const offset = CIRCLE_CIRC * (1 - val / 100);
        integridadeCircle.style.strokeDashoffset = offset;
        integridadePercent.textContent = val + "%";
    }

    // estado inicial 100%
    setIntegridadeProgress(100);

    function ativarLoaderIntegridade() {
        if (!integridadeCircle) return;

        integridadeProg = 0;
        setIntegridadeProgress(0);

        if (integridadeStatus) integridadeStatus.textContent = "calculando hash";
        if (integridadeText) {
            integridadeText.textContent =
                "Estamos recalculando os hashes MD5 dos arquivos duplicados. Isso pode demorar alguns minutos...";
        }

        if (integridadeInterval) {
            clearInterval(integridadeInterval);
        }
        integridadeInterval = setInterval(() => {
            if (integridadeProg < 95) {
                integridadeProg += 1;
                setIntegridadeProgress(integridadeProg);
            }
        }, 250);
    }

    function finalizarLoaderIntegridade(mensagemOk) {
        if (!integridadeCircle) return;

        if (integridadeInterval) {
            clearInterval(integridadeInterval);
            integridadeInterval = null;
        }
        integridadeProg = 100;
        setIntegridadeProgress(100);

        if (integridadeStatus) integridadeStatus.textContent = "conclu√≠do";
        if (integridadeText) {
            integridadeText.textContent =
                mensagemOk || "Recalcular duplicados conclu√≠do. A lista foi atualizada.";
        }
    }

    if (formRecalc) {
        formRecalc.addEventListener("submit", async function (e) {
            if (typeof window.showConfirm === "function") {
                e.preventDefault();

                const ok = await window.showConfirm({
                    title: "Recalcular duplicados?",
                    text: "Esse processo pode demorar alguns minutos, dependendo do tamanho do cache analisado.",
                    confirmLabel: "Iniciar c√°lculo",
                    cancelLabel: "Cancelar",
                    variant: "warning",
                });

                if (!ok) {
                    window.enqueueNotification?.({
                        title: "A√ß√£o cancelada",
                        text: "O rec√°lculo de duplicados foi cancelado.",
                        variant: "info",
                    });
                    return;
                }

                window.enqueueNotification?.({
                    title: "Recalculando duplicados",
                    text: "Estamos analisando o cache em busca de duplicados. Aguarde enquanto est√° sendo feito a an√°lise",
                    variant: "info",
                });

                ativarLoaderIntegridade();
                formRecalc.submit();
            } else {
                ativarLoaderIntegridade();
            }
        });
    }

    const groupsContainer = document.querySelector('#dup-groups');
    if (!groupsContainer) return;

    function collectStatsFromVisibleGroups() {
    const visibleGroups = Array.from(
        document.querySelectorAll(".duplicate-group")
    ).filter(g => g.offsetParent !== null); 

    const byExtSize    = new Map(); 
    const byFolderSize = new Map(); 

    let baseCount  = 0;  
    let dupCount   = 0;  
    let baseBytes  = 0;
    let dupBytes   = 0;
    let totalFiles = 0;

    visibleGroups.forEach(group => {
        // s√≥ linhas realmente vis√≠veis (respeitando filtros de extens√£o/pasta)
        const rows = Array.from(group.querySelectorAll("tbody tr"))
            .filter(r => r.style.display !== "none");

        if (!rows.length) return;

        baseCount += 1;
        totalFiles += rows.length;

        // ===== pasta (continua igual, usa a primeira linha do grupo) =====
        const firstRow = rows[0];
        const pathCell = firstRow.querySelector(".col-path");
        let path = pathCell ? pathCell.textContent.trim() : "";

        let dirPath = path;
        const lastSep = Math.max(path.lastIndexOf("\\"), path.lastIndexOf("/"));
        if (lastSep > 0) {
            dirPath = path.slice(0, lastSep);
        }

        let folderLabel = dirPath;
        if (dirPath) {
            const prevSep = Math.max(dirPath.lastIndexOf("\\"), dirPath.lastIndexOf("/"));
            if (prevSep >= 0) {
                folderLabel = dirPath.slice(prevSep + 1);
            }
        }
        if (!folderLabel) {
            folderLabel = "(raiz)";
        }

        // ===== percorre cada arquivo do grupo =====
        rows.forEach((row, idx) => {
            const rawSize   = row.dataset.sizeBytes || row.getAttribute("data-size-bytes") || "0";
            const sizeBytes = parseInt(rawSize, 10) || 0;

            // --- extens√£o por LINHA (novo) ---
            const nameCell = row.querySelector("td:first-child");
            const fileName = nameCell ? nameCell.textContent.trim() : "";
            let extLabel = "Sem extens√£o";

            if (fileName) {
                const lastDot = fileName.lastIndexOf(".");
                // ignora nomes sem ponto ou come√ßando com ponto (".gitignore")
                if (lastDot > 0 && lastDot < fileName.length - 1) {
                    extLabel = fileName.slice(lastDot).toLowerCase(); // ".py", ".txt"...
                }
            }

            // soma por extens√£o
            byExtSize.set(extLabel, (byExtSize.get(extLabel) || 0) + sizeBytes);
            // soma por pasta (igual antes)
            byFolderSize.set(folderLabel, (byFolderSize.get(folderLabel) || 0) + sizeBytes);

            // base x duplicado (igual antes)
            if (idx === 0) {
                baseBytes += sizeBytes;
            } else {
                dupBytes  += sizeBytes;
                dupCount  += 1;
            }
        });
    });

    return {
        byExtSize,
        byFolderSize,
        baseCount,
        dupCount,
        baseBytes,
        dupBytes,
        totalFiles,
        groupCount: visibleGroups.length,
    };
}


    function buildDatasetFromMap(map, maxItems = 6) {
        const entries = Array.from(map.entries())
            .sort((a, b) => b[1] - a[1])
            .slice(0, maxItems);

        const BYTES_IN_GB = 1024 * 1024 * 1024;
        const BYTES_IN_MB = 1024 * 1024;

        const maxBytes = entries.length ? entries[0][1] : 0;

        let unit = "GB";
        let divisor = BYTES_IN_GB;

        if (maxBytes > 0 && maxBytes < BYTES_IN_GB / 10) {
            unit = "MB";
            divisor = BYTES_IN_MB;
        }

        return {
            labels: entries.map(e => e[0]),
            data:   entries.map(e => e[1] / divisor),
            unit, 
        };
    }

    const extCtx   = document.getElementById("dupExtChart")?.getContext("2d");
    const pastaCtx = document.getElementById("dupFolderChart")?.getContext("2d");
    const wasteCtx = document.getElementById("dupWasteChart")?.getContext("2d");

    let extChart   = null;
    let pastaChart = null;
    let wasteChart = null;
    let extChartUnit = "GB"; // <- unidade atual do gr√°fico de extens√£o

    function updateDupCharts() {
        const stats = collectStatsFromVisibleGroups();

        const BYTES_IN_GB = 1024 * 1024 * 1024;
        const baseGB = stats.baseBytes / BYTES_IN_GB;
        const dupGB  = stats.dupBytes  / BYTES_IN_GB;

        const counterEl = document.getElementById("dup-counter");
        if (counterEl) {
            counterEl.textContent =
                `${stats.totalFiles} arquivo(s) nesta p√°gina ` +
                `(${stats.groupCount} grupo(s), ${stats.dupCount} duplicado(s) extra).`;
        }

        // --- donut de impacto (√∫nicos x duplicados) ---
        if (wasteCtx) {
            const data = [stats.baseCount, stats.dupCount];

            if (!wasteChart) {
                wasteChart = new Chart(wasteCtx, {
                    type: "doughnut",
                    data: {
                        labels: ["Arquivos √∫nicos", "Arquivos duplicados"],
                        datasets: [{
                            data: data,
                        }]
                    },
                    options: {
                        responsive: true,
                        cutout: "60%",
                        plugins: {
                            legend: {
                                position: "bottom"
                            },
                            tooltip: {
                                callbacks: {
                                    label: ctx =>
                                        `${ctx.label}: ${ctx.raw} arquivo(s)`
                                }
                            }
                        }
                    }
                });
            } else {
                wasteChart.data.datasets[0].data = data;
                wasteChart.update();
            }
        }

        if (extCtx) {
            const extData = buildDatasetFromMap(stats.byExtSize);
            extChartUnit = extData.unit; 

            const labels = extData.labels.length ? extData.labels : ["Sem dados"];
            const data   = extData.labels.length ? extData.data   : [1];

            if (!extChart) {
                extChart = new Chart(extCtx, {
                    type: "doughnut",          // üëà virou pizza
                    data: {
                        labels: labels,
                        datasets: [{
                            data: data,
                            // cores diferentes pra cada fatia (opcional, pode tirar que o Chart.js gera)
                            backgroundColor: [
                                "rgba(59,130,246,0.9)",
                                "rgba(34,197,94,0.9)",
                                "rgba(249,115,22,0.9)",
                                "rgba(236,72,153,0.9)",
                                "rgba(14,165,233,0.9)",
                                "rgba(148,163,184,0.9)"
                            ],
                            borderWidth: 1,
                        }]
                    },
                    options: {
                        responsive: true,
                        cutout: "55%",          // donut; se quiser pizza cheia, p√µe "0"
                        plugins: {
                            legend: {
                                position: "bottom",
                            },
                            tooltip: {
                                callbacks: {
                                    label: ctx => {
                                        const label = ctx.label || "";
                                        const val   = ctx.parsed || 0;
                                        return `${label}: ${val.toFixed(3)} ${extChartUnit}`;
                                    }
                                }
                            }
                        }
                    }
                });
            } else {
                extChart.data.labels = labels;
                extChart.data.datasets[0].data = data;
                extChart.update();
            }
        }

        if (pastaCtx) {
            const pastaData = buildDatasetFromMap(stats.byFolderSize);

            const pastaLabels = pastaData.labels.map(lbl => compactFolderLabel(lbl));

            if (!pastaChart) {
                pastaChart = new Chart(pastaCtx, {
                    type: "doughnut",
                    data: {
                        labels: pastaLabels,
                        datasets: [{
                            data: pastaData.data,
                        }]
                    },
                    options: {
                        responsive: true,
                        cutout: "60%",
                        plugins: {
                            legend: {
                                position: "bottom",
                            },
                            tooltip: {
                                callbacks: {
                                    label: ctx =>
                                        `${ctx.label}: ${ctx.parsed.toFixed(2)} GB`
                                }
                            }
                        }
                    }
                });
            } else {
                pastaChart.data.labels = pastaLabels;
                pastaChart.data.datasets[0].data = pastaData.data;
                pastaChart.update();
            }
        }
    }


    function filtrarGrupo(group) {
        const extValue   = (filtroExt.value   || "").trim().toLowerCase();
        const pastaValue = (filtroPasta.value || "").trim().toLowerCase();

        const rows = group.querySelectorAll("tbody tr");
        let linhasVisiveis = 0;

        rows.forEach(row => {
            const colPath = row.querySelector(".col-path");
            const colNome = row.querySelector("td:first-child");

            const pathText = (colPath ? colPath.textContent : "").toLowerCase();
            const nomeText = (colNome ? colNome.textContent : "").toLowerCase();

            let okExt   = true;
            let okPasta = true;

            if (extValue) {
                const filtroComPonto = extValue.startsWith(".")
                    ? extValue
                    : "." + extValue;

                okExt = nomeText.includes(filtroComPonto) || pathText.includes(filtroComPonto);
            }

            if (pastaValue) {
                okPasta = pathText.includes(pastaValue);
            }

            const mostrar = okExt && okPasta;
            row.style.display = mostrar ? "" : "none";
            if (mostrar) linhasVisiveis++;
        });

        return linhasVisiveis > 0;
    }

    const instance = window.initCardFilter({
        container: '#dup-groups',
        itemSelector: '.duplicate-group',
        controls: '#dup-pagination',
        perPage: 4,
        perPageOptions: [4, 10, 20, 50],
        customFilter: filtrarGrupo,
        onStatsChange({ pageItems, filteredTotal }) {
            if (infoEl) {
                infoEl.textContent =
                    `Mostrando ${pageItems} de ${filteredTotal} grupos de duplicados.`;
            }
            updateDupCharts();
        }
    });

    if (!instance) return;

    updateDupCharts();

    function atualizarFiltro() {
        instance.refresh();
    }

    if (filtroExt)   filtroExt.addEventListener("input", atualizarFiltro);
    if (filtroPasta) filtroPasta.addEventListener("input", atualizarFiltro);
});
</script>



{% endblock %}
